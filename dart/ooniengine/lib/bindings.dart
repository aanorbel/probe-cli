// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

class OONIEngineFFI {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  OONIEngineFFI(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  OONIEngineFFI.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Starts a new task inside the OONI engine using protobuf v3.
  ///
  /// Note that this function copies both the name string and the base
  /// byte array meaning that it's inefficient with large messages. However,
  /// OONI does not need to exchange very large messages.
  ///
  /// @param name The name of the task to start.
  ///
  /// @param base Base of the buffer containing protobuf-serialized data.
  ///
  /// @param len Length of the buffer pointed by base.
  ///
  /// @return A negative value on failure. In such a case, the OONI engine
  /// will print a diagnostic message on the standard error.
  ///
  /// @return A zero-or-positive unique task identifier on success. In such a
  /// case, you own the task and must call OONITaskFree when done using it.
  int OONITaskStart(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Void> base,
    int len,
  ) {
    return _OONITaskStart(
      name,
      base,
      len,
    );
  }

  late final _OONITaskStartPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>,
              ffi.Int)>>('OONITaskStart');
  late final _OONITaskStart = _OONITaskStartPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>, int)>();

  /// Blocks waiting for [taskID] to emit an event or for [timeout] to expire.
  ///
  /// The returned memory is allocated using this library's allocator and
  /// should only be freed using the OONIEventFree function call.
  ///
  /// @param taskID Unique task identifier returned by OONITaskStart.
  ///
  /// @param timeout Maximum number of milliseconds to wait for the next event
  /// to become available. Use a negative value to wait for the next event without
  /// any timeout (not recommended in general).
  ///
  /// @return A NULL value if the task does not exist, the timeout expires,
  /// or an internal error occurs. Otherwise, the call succeded and you
  /// are given ownership of an OONIEvent containing the next task-emitted event.
  ffi.Pointer<OONIEvent> OONITaskWaitForNextEvent(
    int taskID,
    int timeout,
  ) {
    return _OONITaskWaitForNextEvent(
      taskID,
      timeout,
    );
  }

  late final _OONITaskWaitForNextEventPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OONIEvent> Function(
              ffi.Int, ffi.Int)>>('OONITaskWaitForNextEvent');
  late final _OONITaskWaitForNextEvent = _OONITaskWaitForNextEventPtr
      .asFunction<ffi.Pointer<OONIEvent> Function(int, int)>();

  /// Frees an [event] previously returned by OONITaskWaitForNextEvent.
  void OONIEventFree(
    ffi.Pointer<OONIEvent> event,
  ) {
    return _OONIEventFree(
      event,
    );
  }

  late final _OONIEventFreePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<OONIEvent>)>>(
          'OONIEventFree');
  late final _OONIEventFree =
      _OONIEventFreePtr.asFunction<void Function(ffi.Pointer<OONIEvent>)>();

  /// Returns whether the task identified by [taskID] is done. A taks is done
  /// when it has finished running and its events queue has been drained.
  ///
  /// @param taskID Unique task identifier returned by OONITaskStart.
  ///
  /// @return Zero if the task exists and either is still running or has some
  /// unread events inside its events queue, nonzero otherwise.
  int OONITaskIsDone(
    int taskID,
  ) {
    return _OONITaskIsDone(
      taskID,
    );
  }

  late final _OONITaskIsDonePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('OONITaskIsDone');
  late final _OONITaskIsDone =
      _OONITaskIsDonePtr.asFunction<int Function(int)>();

  /// Notifies the task identified by [taskID] to stop ASAP.
  ///
  /// @param taskID Unique task identifier returned by OONITaskStart.
  void OONITaskInterrupt(
    int taskID,
  ) {
    return _OONITaskInterrupt(
      taskID,
    );
  }

  late final _OONITaskInterruptPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>(
          'OONITaskInterrupt');
  late final _OONITaskInterrupt =
      _OONITaskInterruptPtr.asFunction<void Function(int)>();

  /// Frees the memory associated with [taskID]. If the task is still running, this
  /// function will also interrupt it and drain its events queue.
  ///
  /// @param taskID Unique task identifier returned by OONITaskStart.
  void OONITaskFree(
    int taskID,
  ) {
    return _OONITaskFree(
      taskID,
    );
  }

  late final _OONITaskFreePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('OONITaskFree');
  late final _OONITaskFree = _OONITaskFreePtr.asFunction<void Function(int)>();
}

/// OONIEvent is an event emitted by the OONI engine.
class OONIEvent extends ffi.Struct {
  /// Name of the event.
  external ffi.Pointer<ffi.Char> Name;

  /// Base pointer to the array containing protobuf v3 data.
  external ffi.Pointer<ffi.Void> Base;

  /// The length of the array pointed by Base.
  @ffi.Int()
  external int Len;
}
