package {{ .Package }}

//
// Measurer for {{ .Name }}.
//
// The Measurer implements performing a single measurement. Because this
// autogenerated code is optimized to run background tasks, this code's
// main job is to parse inputs and then schedule the "main" task implementing
// the experiment. As such, there is little to change for you here.
//

import (
	"context"
	"errors"
	"sync"

	"github.com/ooni/probe-cli/v3/internal/atomicx"
	"github.com/ooni/probe-cli/v3/internal/measurexlite"
	"github.com/ooni/probe-cli/v3/internal/model"
)

// Measurer implements the {{ .Name }} experiment.
type Measurer struct{
	// Config contains the experiment's config.
	Config *Config
}

// NewExperimentMeasurer creates a new model.ExperimentMeasurer for {{ .Name }}.
//
// Code in the internal/registry package binds this function with an ExperimentBuilder
// which is responsible of instantiating a new experiment.
func NewExperimentMeasurer(config *Config) model.ExperimentMeasurer {
	return &Measurer{
		Config: config,
	}
}

// ExperimentName implements model.ExperimentMeasurer.
func (m *Measurer) ExperimentName() string {
	return "{{ .Name }}"
}

// ExperimentVersion implements model.ExperimentMeasurer.
func (m *Measurer) ExperimentVersion() string {
	return "{{ .Version }}"
}

// Run implements model.ExperimentMeasurer.
func (m *Measurer) Run(ctx context.Context, sess model.ExperimentSession,
	measurement *model.Measurement, callbacks model.ExperimentCallbacks) error {
	// Reminder: When this function returns an error, the measurement result
	// WILL NOT be submitted to the OONI backend. You SHOULD only return an error
	// for fundamental errors (e.g., the input is invalid or missing).

	{{ if eq .InputPolicy "InputNone" }}
	// honour {{ .InputPolicy }}
	if measurement.Input != "" {
		return errors.New("this experiment does not take any input")
	}

	{{ else if eq .InputPolicy "InputOptional" }}
	// honour {{ .InputPolicy }}
	input := measurement.Input
	if input == "" {
		input = m.defaultInput()
	}

	{{ else }}
	// honour {{ .InputPolicy }}
	input := measurement.Input
	if input == "" {
		return errors.New("no input provided")
	}
	{{ end }}

	{{ if ne .InputPolicy "InputNone" }}
	// convert the input string to a URL
	inputParser := &InputParser{
		AcceptedSchemes: []string{"http", "https"}, // TODO: you may want to change this
		AllowEndpoints:  false,                     // TODO: you may want to change this
		DefaultScheme:   "",                        // TODO: you may want to change this
	}
	URL, err := inputParser.Parse(string(measurement.Input))
	if err != nil {
		return err
	}
	{{ end }}

	// initialize the experiment's test keys
	tk := NewTestKeys()
	measurement.TestKeys = tk

	// create variables required to run parallel tasks
	idGenerator := &atomicx.Int64{}
	wg := &sync.WaitGroup{}

	// start background tasks
	// TODO: replace this code with code for running your background tasks
	{{ if ne .InputPolicy "InputNone" }}_ = URL{{ end }}
	wg.Add(1)
	go func(logger model.Logger, idx int64) {
		defer wg.Done()
		ol := measurexlite.NewOperationLogger(logger, "{{ .Package }}#%d", idx)
		tk.SetFundamentalFailure(errors.New("experiment not implemented"))
		ol.Stop(nil)
	}(sess.Logger(), idGenerator.Add(1))

	// wait for background tasks to join
	wg.Wait()

	// return whether there was a fundamental failure, which would prevent
	// the measurement from being submitted to the OONI collector.
	return tk.FundamentalFailure()
}

{{ if eq .InputPolicy "InputOptional" }}
// defaultInput returns the default input value when input is not present
func (m *Measurer) defaultInput() model.MeasurementTarget {
	// TODO: implement
	panic("not implemented")
}
{{ end }}
