package {{ .Package }}

//
// The main task of the {{ .Name }} experiment.
//
// This autogenerated code is for a multi-task experiment. This
// means that the "main" function of the experiment, i.e.,
// Measurer.Run will instantiate the MainTask, execute it and
// wait for it, and its child tasks, to complete. So, this
// file is the one that deserves most of your attention.
//
// You _may_ want to autogenerate specific tasks (e.g., TLS
// handshake or DNS lookup) using boilerplate's `new-task`
// subcommand. This subcommand will give you a good starting
// point for performing specific submeasurements.
//
// Note: the autogenerated code contains a very basic task
// that does ~nothing. You should, of course, edit it!
//

import (
	"context"
	"fmt"
	{{ if ne .InputPolicy "InputNone" }}"net/url"{{ end }}
	"time"

	"github.com/ooni/probe-cli/v3/internal/model"
)

// MainTask is the main task.
type MainTask struct {
	// IDGenerator is the TaskIDGenerator to use.
	IDGenerator *TaskIDGenerator

	// Logger is the logger to use.
	Logger model.Logger

	// TestKeys contains the TestKeys.
	TestKeys TestKeys

	// ZeroTime is the zero time of the measurement.
	ZeroTime time.Time

	{{ if ne .InputPolicy "InputNone" }}
	// Input contains the parsed experiment input.
	Input *url.URL
	{{ end }}

	// TODO: add fields.
	//
	// Please, keep in mind that, with multiple tasks you should
	// most like only share fields as read-only here!
	//
	// Please, keep the field names sorted alphabetically!
}

// NewMainTask creates a new MainTask instance.
//
// Arguments:
//
// - idGenerator allows us to generate unique IDs for each measurement, such
// that we can recognize which observation originates from which submeasurement;
//
// - logger is the logger to use;
//
// - tk contains the TestKeys where to write results;
//
// - zeroTime is the measurement's zero time;{{ if ne .InputPolicy "InputNone" }}
//
// - input contains the experiment's input;{{ end }}
//
// TODO: add the required parameters and document them.
func NewMainTask(idGenerator *TaskIDGenerator, logger model.Logger,
	tk TestKeys, zeroTime time.Time, {{ if ne .InputPolicy "InputNone" }}input *url.URL{{ end }}) *MainTask {
	return &MainTask{
		IDGenerator: idGenerator,
		Logger:      logger,
		TestKeys:    tk,
		ZeroTime:    zeroTime,
		{{ if ne .InputPolicy "InputNone" }}
		Input:       input,
		{{ end }}
		// TODO: fill newly-added fields.
	}
}

// Run implements Task
func (t *MainTask) Run(ctx context.Context, sched TaskScheduler) error {
	// TODO: here you should start you child tasks.
	//
	// You can use `boilerplate new-task` to automatically generate code for
	// predefined tasks (e.g., HTTP GET, TLS handshake).
	t.Logger.Infof("Hello, world")
	return nil
}

// Repr implements Task
func (t *MainTask) Repr() string {
	return fmt.Sprintf("{{ .Package }}Task: %+v", t) // TODO: make this prettier
}
