package {{ .Name }}

//
// Library for running background tasks.
//
// Note: the autogenerated code contains a generic library but you
// may want to further customize what we do depending on specific
// needs that your experiment may actually have.
//

import (
	"context"
	"sync"

	"github.com/ooni/probe-cli/v3/internal/atomicx"
	"github.com/ooni/probe-cli/v3/internal/measurexlite"
	"github.com/ooni/probe-cli/v3/internal/model"
)

// TaskIDGenerator generates unique IDs for tasks.
type TaskIDGenerator struct {
	c *atomicx.Int64
}

// NewTaskIDGenerator creates a new TaskIDGenerator instance.
func NewTaskIDGenerator() *TaskIDGenerator {
	return &TaskIDGenerator{
		c: &atomicx.Int64{},
	}
}

// Next returns the next unique task ID.
func (ig *TaskIDGenerator) Next() int64 {
	return ig.c.Add(1)
}

// TaskScheduler schedules new tasks.
type TaskScheduler interface {
	// Start schedules a task for executing ASAP.
	Start(ctx context.Context, task Task)
}

// TaskSchedulerWaiter schedules new tasks and waits for them.
type TaskSchedulerWaiter interface {
	// We inherit from the TaskScheduler.
	TaskScheduler

	// Waits for all tasks to finish.
	Wait()
}

// taskScheduler implements TaskScheduler.
type taskScheduler struct {
	// logger is the logger to use.
	logger model.Logger

	// sema contains a semaphore for throttling concurrent tasks.
	sema chan bool

	// wg is the wait group to wait for completion.
	wg *sync.WaitGroup
}

// NewTaskSchedulerWaiter creates a new TaskSchedulerWaiter instance. The [maxTasks]
// argument controls the parallelism. A zero or negative argument implies
// only a single task at a time could run. The [logger] argument is the
// logger we should use to print information about tasks completion. You
// should use the [model.DiscardLogger] singleton to disable this functionality.
func NewTaskSchedulerWaiter(logger model.Logger, maxTasks int) TaskSchedulerWaiter {
	if maxTasks < 1 {
		maxTasks = 1 // as documented
	}
	tl := &taskScheduler{
		logger:  logger,
		sema:    make(chan bool, maxTasks),
		wg:      &sync.WaitGroup{},
	}
	return tl
}

// Task is one of the tasks run by this experiment.
type Task interface {
	// Repr returns a printable representation of the task.
	Repr() string

	// Run runs the task and returns the result.
	Run(ctx context.Context, sched TaskScheduler) error
}

// Start implements TaskScheduler.
func (ts *taskScheduler) Start(ctx context.Context, task Task) {
	wrapper := &taskWrapper{
		logger: ts.logger,
		sema:   ts.sema,
		task:   task,
		wg:     ts.wg,
	}
	ts.wg.Add(1)
	go wrapper.run(ctx, ts)
}

// Wait implements TaskScheduler.
func (ts *taskScheduler) Wait() {
	ts.wg.Wait()
}

// taskWrapper wraps a task encapsulating scheduling logic.
type taskWrapper struct {
  // logger is the logger to use.
  logger model.Logger

  // sema is the controlling semaphore.
  sema chan bool

  // task is the actual task.
  task Task

  // wg allows the parent to wait for jobs to terminate.
  wg *sync.WaitGroup
}

// Runs the task.
func (tw *taskWrapper) run(ctx context.Context, sched TaskScheduler) {
  // Ensure we don't have too many concurrent tasks.
  tw.sema <- true
  defer func() { <-tw.sema }()

  // Synchronize with the parent task.
  defer tw.wg.Done()

  // Create operation logger.
  ol := measurexlite.NewOperationLogger(tw.logger, tw.task.Repr())

  // Run task.
  err := tw.task.Run(ctx, sched)

  // Task completed.
  ol.Stop(err)
}
