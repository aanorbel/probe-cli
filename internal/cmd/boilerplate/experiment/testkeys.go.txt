package {{ .Package }}

//
// TestKeys for {{ .Name }}.
//
// Note: for historical reasons, we call TestKeys the JSON object
// containing the results produced by OONI experiments.
//

import "sync"

// TestKeys is the thread-safe interface with which you access the real
// content of the test keys, contained by [testKeys].
type TestKeys interface {
	// TODO: define thread-safe setters for the real test keys. You may also
	// want to create getters _if_ you need to access specific content inside
	// the Measurer.Run func. For example, we do that for fundamentalFailure
	// because we need to know whether the overall experiment failed.

	// SetFundamentalFailure sets [testKeys.fundamentalFailure].
	SetFundamentalFailure(err error)

	// FundamentalFailure gets [testKeys.fundamentalFailure].
	FundamentalFailure() error
}

// testKeys contains the results produced by {{ .Name }}.
type testKeys struct {
	// TODO: add here fields produced by this experiment. They should
	// be public such that we can JSON serialize them.
	//
	// Ideally, try to keep the field names alphabetically sorted.
	//
	// For example:
	//
	// // Blocked indicates that the resource is censored.
	// Blocked bool `json:"blocked"

	// fundamentalFailure indicates that some fundamental error occurred
	// in a background task. A fundamental error is something like a programmer
	// such as a failure to parse a URL that was hardcoded in the codebase. When
	// this class of errors happens, you certainly don't want to submit the
	// resulting measurement to the OONI collector.
	fundamentalFailure error

	// mu provides mutual exclusion for accessing the test keys.
	mu *sync.Mutex
}

var _ TestKeys = &testKeys{}

// TODO: implement thread-safe setters for the real test keys. This allows
// tasks to write directly into the TestKeys.
//
// For example:
//
// func (tk *testKeys) SetBlocked(blocked bool) {
//   tk.mu.Lock()
//   tk.Blocked = blocked
//   tk.mu.Unlock()
// }
//
// In some cases, you may also need to write thread-safe getters. For example,
// below we also define a getter for fundamentalFailure because we need to
// read its value inside the autogenerated Runner.Main func.

// SetFundamentalFailure implements TestKeys.
func (tk *testKeys) SetFundamentalFailure(err error) {
	tk.mu.Lock()
	tk.fundamentalFailure = err
	tk.mu.Unlock()
}

// FundamentalFailure implements TestKeys.
func (tk *testKeys) FundamentalFailure() error {
	tk.mu.Lock()
	err := tk.fundamentalFailure
	tk.mu.Unlock()
	return err
}

// NewTestKeys creates a new instance of TestKeys.
func NewTestKeys() TestKeys {
	return &testKeys{
		// TODO: here you should initialize all the fields
	}
}
