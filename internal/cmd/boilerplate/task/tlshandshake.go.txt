package {{ .Package }}

//
// {{ .StructName }}: {{ .Description }}
//
// This task implements the {{ .Template }} template.
//

import (
	"context"
	"crypto/tls"
	"fmt"
	"time"

	"github.com/ooni/probe-cli/v3/internal/measurexlite"
	"github.com/ooni/probe-cli/v3/internal/model"
	"github.com/ooni/probe-cli/v3/internal/netxlite"
)

// {{ .Description }}
type {{ .StructName }}Task struct {
	// ALPN is the ALPN to use.
	ALPN []string

	// Address is the address to connect to.
	Address string

	// IDGenerator is the TaskIDgenerator to use.
	IDGenerator *TaskIDGenerator

	// Logger is the logger to use.
	Logger model.Logger

	// TestKeys contains the TestKeys.
	TestKeys *TestKeys

	// SNI is the SNI to use.
	SNI string

	// ZeroTime is the measurement's zero time.
	ZeroTime time.Time
}

// New{{ .StructName}}Task creates a new {{ .StructName }}Task instance.
//
// Arguments:
//
// - address is the address to connect to;
//
// - alpn is the ALPN to use;
//
// - sni is the SNI to use;
//
// - idGenerator is the TaskIDGenerator to use;
//
// - logger is the logger to use;
//
// - tk contains the TestKeys;
//
// - zeroTime is the zero time of the measurement.
func New{{ .StructName }}Task(address string, alpn []string, sni string, idGenerator *TaskIDGenerator,
	logger model.Logger, tk *TestKeys, zeroTime time.Time) *{{ .StructName }}Task {
	return &{{ .StructName }}Task{
		Address:     address,
		ALPN:        alpn,
		IDGenerator: idGenerator,
		Logger:      logger,
		SNI:         sni,
		TestKeys:    tk,
		ZeroTime:    zeroTime,
	}
}

var _ Task = &{{ .StructName }}Task{}

// Run implements Task
func (t *{{ .StructName }}Task) Run(ctx context.Context, sched TaskScheduler) error {
	// 1. configure timeout for this task
	const defaultTimeout = 15 * time.Second // TODO: you may want to change this default
	ctx, cancel := context.WithTimeout(ctx, defaultTimeout)
	defer cancel()

	// 2. create a trace
	trace := measurexlite.NewTrace(t.IDGenerator.Next(), t.ZeroTime)

	// 3. perform the TCP connect
	dialer := trace.NewDialerWithoutResolver(t.Logger)
	conn, err := dialer.DialContext(ctx, "tcp", t.Address)
	t.onTCPConnectResult(err, <-trace.TCPConnect)
	if err != nil {
		return err
	}
	conn = trace.WrapNetConn(conn)
	defer conn.Close()

	// 4. TLS handshake
	thx := trace.NewTLSHandshakerStdlib(t.Logger)
	config := &tls.Config{
		NextProtos: t.ALPN,
		RootCAs:    netxlite.NewDefaultCertPool(),
		ServerName: t.SNI,
	}
	tlsConn, _, err := thx.Handshake(ctx, conn, config)
	t.onTLSHandshakeResult(err, <-trace.TLSHandshake, trace.NetworkEvents())
	if err != nil {
		return err
	}
	tlsConn.Close()

	// 5. we're done!
	return nil
}

// Called when the result of the TCP connect becomes available.
//
// Arguments:
//
// - err is the possibly nil error;
//
// - tcpTrace contains the never-nil archival results.
func (t *{{ .StructName }}Task) onTCPConnectResult(
	err error, tcpTrace *model.ArchivalTCPConnectResult) {
	// TODO: implement this method. Typically here you want to
	// save into the test keys using thread safe code.
}

// Called when the result of the TLS handshake becomes available.
//
// Arguments:
//
// - err is the possibly-nil error;
//
// - tlsTrace contains the never-nil archival results;
//
// - netEvents contains the possibly empty network events.
func (t *{{ .StructName }}Task) onTLSHandshakeResult(
	err error, tlsTrace *model.ArchivalTLSOrQUICHandshakeResult,
	netEvents []*model.ArchivalNetworkEvent) {
	// TODO: implement this method. Typically here you want to
	// save into the test keys using thread safe code.
}

// Repr implements Task
func (t *{{ .StructName }}Task) Repr() string {
	return fmt.Sprintf("{{ .StructName}}Task: %+v", t) // TODO: make this prettier
}
