package {{ .Package }}

//
// {{ .StructName }}
//
// This code was generated by `boilerplate' using
// the {{ .Template }} template.
//

import (
	"context"
	"sync"
	"time"

	"github.com/ooni/probe-cli/v3/internal/atomicx"
	"github.com/ooni/probe-cli/v3/internal/measurexlite"
	"github.com/ooni/probe-cli/v3/internal/model"
)

// {{ .Description }}
//
// The zero value of this structure IS NOT valid and you MUST initialize
// all the fields marked as MANDATORY before using this structure.
type {{ .StructName }} struct {
	// Domain is the MANDATORY domain to resolve.
	Domain string

	// IDGenerator is the MANDATORY atomic int64 to generate task IDs.
	IDGenerator *atomicx.Int64

	// Logger is the MANDATORY logger to use.
	Logger model.Logger

	// TestKeys is MANDATORY and contains the TestKeys.
	TestKeys *TestKeys

	// ZeroTime is the MANDATORY zero time of the measurement.
	ZeroTime time.Time

	// WaitGroup is the MANDATORY wait group this task belongs to.
	WaitGroup *sync.WaitGroup
}

// Start starts this task in a background goroutine.
func (t *{{ .StructName }}) Start(ctx context.Context) {
	t.WaitGroup.Add(1)
	index := t.IDGenerator.Add(1)
	go func() {
		defer t.WaitGroup.Done() // synchronize with the parent
		t.Run(ctx, index)
	}()
}

// Run runs this task in the current goroutine.
func (t *{{ .StructName }}) Run(parentCtx context.Context, index int64) {
	// create context with attached a timeout
	const timeout = 4 * time.Second // TODO: consider changing
	lookupCtx, lookpCancel := context.WithTimeout(parentCtx, timeout)
	defer lookpCancel()

	// create trace
	trace := measurexlite.NewTrace(index, t.ZeroTime)

	// start the operation logger
	ol := measurexlite.NewOperationLogger(t.Logger, "{{ .StructName }}#%d", index) // TODO: edit

	// runs the lookup
	reso := trace.NewStdlibResolver(t.Logger)
	addrs, err := reso.LookupHost(lookupCtx, t.Domain)
	_ = trace.DNSLookupsFromRoundTrip() // TODO: save
	if err != nil {
		ol.Stop(err)
		return
	}

	// emit successful log message
	ol.Stop(nil)

	// (typically) fan out a number of child async tasks to use the IP addrs
	for range addrs {
		// TODO: implement
	}
}
