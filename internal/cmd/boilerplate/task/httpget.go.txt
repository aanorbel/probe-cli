package {{ .Package }}

//
// {{ .StructName }}: {{ .Description }}
//
// This task implements the {{ .Template }} template.
//

import (
	"context"
	"fmt"
	"io"
	"net"
	"net/http"
	"net/url"
	"time"

	"github.com/ooni/probe-cli/v3/internal/measurex"
	"github.com/ooni/probe-cli/v3/internal/measurexlite"
	"github.com/ooni/probe-cli/v3/internal/model"
	"github.com/ooni/probe-cli/v3/internal/netxlite"
)

// {{ .Description }}
type {{ .StructName }}Task struct {
	// Address is the address to connect to.
	Address string

	// IDGenerator is the TaskIDgenerator to use.
	IDGenerator *TaskIDGenerator

	// Logger is the logger to use.
	Logger model.Logger

	// TestKeys contains the TestKeys.
	TestKeys TestKeys

	// URLPath is the URL's path.
	URLPath string

	// ZeroTime is the measurement's zero time.
	ZeroTime time.Time
}

// New{{ .StructName}}Task creates a new {{ .StructName }}Task instance.
//
// Arguments:
//
// - address is the address to connect to;
//
// - idGenerator is the TaskIDGenerator to use;
//
// - logger is the logger to use;
//
// - tk contains the TestKeys;
//
// - urlPath is the URL path to use;
//
// - zeroTime is the zero time of the measurement.
func New{{ .StructName }}Task(address string, idGenerator *TaskIDGenerator,
	logger model.Logger, tk TestKeys, urlPath string, zeroTime time.Time) *{{ .StructName }}Task {
	return &{{ .StructName }}Task{
		Address:     address,
		IDGenerator: idGenerator,
		Logger:      logger,
		TestKeys:    tk,
		URLPath:     urlPath,
		ZeroTime:    zeroTime,
	}
}

var _ Task = &{{ .StructName }}Task{}

// Run implements Task
func (t *{{ .StructName }}Task) Run(ctx context.Context, sched TaskScheduler) error {
	// 1. configure timeout for this task
	const defaultTimeout = 15 * time.Second // TODO: you may want to change this default
	ctx, cancel := context.WithTimeout(ctx, defaultTimeout)
	defer cancel()

	// 2. create a trace
	trace := measurexlite.NewTrace(t.IDGenerator.Next(), t.ZeroTime)

	// 3. perform the TCP connect
	dialer := trace.NewDialerWithoutResolver(t.Logger)
	conn, err := dialer.DialContext(ctx, "tcp", t.Address)
	t.onTCPConnectResult(err, <-trace.TCPConnect)
	if err != nil {
		return err
	}
	defer conn.Close()

	// 4. perform the plaintext HTTP GET
	URL := &url.URL{
		Scheme: "http",
		Host:   t.hostHeader(),
	}
	// TODO(bassosimone): we should expose this function from measurexlite
	req, err := measurex.NewHTTPRequestWithContext(ctx, "GET", URL.String(), nil)
	if err != nil {
		t.onNewHTTPRequestFailure(err)
		return err
	}
	// TODO(bassosimone): we should implement HTTP tracing in measurexlite
	txp := netxlite.NewHTTPTransport(
		t.Logger,
		netxlite.NewSingleUseDialer(conn),
		netxlite.NewNullTLSDialer(),
	)
	defer txp.CloseIdleConnections()
	resp, err := txp.RoundTrip(req)
	if err != nil {
		t.onHTTPTransactionResult(resp, nil, err)
		return err
	}
	defer resp.Body.Close()

	// 5. read the response body
	const maxResponseSize = 1 << 22 // TODO: you may want to change this default
	reader := io.LimitReader(resp.Body, maxResponseSize)
	data, err := netxlite.ReadAllContext(ctx, reader)
	if err != nil {
		t.onHTTPTransactionResult(resp, nil, err)
		return err
	}

	// 4. we're done!
	return t.onHTTPTransactionResult(resp, data, nil)
}

// Called when the result of the TCP connect becomes available.
//
// Arguments:
//
// - err is the possibly nil error;
//
// - tcpTrace contains the never-nil archival results.
func (t *{{ .StructName }}Task) onTCPConnectResult(
	err error, tcpTrace *model.ArchivalTCPConnectResult) {
	// TODO: implement this method. Typically here you want to
	// save into the test keys using thread safe code.
}

// Called when we fail to create a new HTTP request.
//
// This typically indicates that something was off in the experiment's
// settings and could be caused by an implementation error.
func (t *{{ .StructName}}Task) onNewHTTPRequestFailure(err error) {
	// TODO: implement this method. Typically here you want to
	// save into the test keys using thread safe code.
}

// Called when the results of the HTTP transaction become available.
//
// Arguments:
//
// - resp is the possibly-nil HTTP response;
//
// - respBody is the possibly-nil-or-empty HTTP body;
//
// - err is the possibly-nil error.
func (t *{{ .StructName }}Task) onHTTPTransactionResult(
	resp *http.Response, respBody []byte, err error) error {
	// TODO: implement this method. Typically here you want to
	// save into the test keys using thread safe code.
	return nil
}

// Returns the host header without the port if we're using the default
// port. Otherwise, it returns the host header with the port.
func (t *{{ .StructName }}Task) hostHeader() string {
	addr, port, err := net.SplitHostPort(t.Address)
	if err != nil {
		t.Logger.Warnf("BUG: net.SplitHostPort failed for %s: %s", t.Address, err.Error())
		return t.Address
	}
	if port == "80" {
		return addr
	}
	return t.Address // there was no need to parse after all ðŸ˜¬
}

// Repr implements Task
func (t *{{ .StructName }}Task) Repr() string {
	return fmt.Sprintf("{{ .StructName}}Task: %+v", t) // TODO: make this prettier
}
