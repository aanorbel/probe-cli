package webconnectivity

//
// Redirects
//
// This code was generated by `boilerplate' using
// the http template.
//

import (
	"bytes"
	"context"

	"io"
	"net/http"
	"net/url"
	"sync"
	"time"

	"github.com/ooni/probe-cli/v3/internal/atomicx"
	"github.com/ooni/probe-cli/v3/internal/measurexlite"
	"github.com/ooni/probe-cli/v3/internal/model"
	"github.com/ooni/probe-cli/v3/internal/netxlite"
)

// Follows subsequent redirects. We use a step-by-step style for the
// first URL and we use tracing for subsequent redirects.
//
// The zero value of this structure IS NOT valid and you MUST initialize
// all the fields marked as MANDATORY before using this structure.
type Redirects struct {
	// IDGenerator is the MANDATORY atomic int64 to generate task IDs.
	IDGenerator *atomicx.Int64

	// Location is the MANDATORY location we were redirected to.
	Location *url.URL

	// Logger is the MANDATORY logger to use.
	Logger model.Logger

	// TestKeys is MANDATORY and contains the TestKeys.
	TestKeys *TestKeys

	// ZeroTime is the MANDATORY measurement's zero time.
	ZeroTime time.Time

	// WaitGroup is the MANDATORY wait group this task belongs to.
	WaitGroup *sync.WaitGroup
}

// Start starts this task in a background goroutine.
func (t *Redirects) Start(ctx context.Context) {
	t.WaitGroup.Add(1)
	index := t.IDGenerator.Add(1)
	go func() {
		defer t.WaitGroup.Done() // synchronize with the parent
		t.Run(ctx, index)
	}()
}

// Run runs this task in the current goroutine.
func (t *Redirects) Run(parentCtx context.Context, index int64) {
	// create trace
	trace := measurexlite.NewTrace(index, t.ZeroTime)

	// start the operation logger
	ol := measurexlite.NewOperationLogger(t.Logger, "Redirects#%d", index) // TODO: edit

	// create context with a timeout
	const tcpTimeout = 10 * time.Second
	httpCtx, httpCancel := context.WithTimeout(parentCtx, tcpTimeout)
	defer httpCancel()

	// create dialers for the transport
	dialer := netxlite.NewDialerWithStdlibResolver(t.Logger)
	tlsDialer := netxlite.NewTLSDialer(dialer, netxlite.NewTLSHandshakerStdlib(t.Logger))

	// create HTTP transport
	httpTransport := netxlite.NewHTTPTransport(t.Logger, dialer, tlsDialer)

	// TODO(bassosimone): we need to configure cookies
	// TODO(bassosimone): we need to configure the referer

	// create HTTP client
	httpClnt := &http.Client{
		Transport: &redirectsTransport{
			tk:    t.TestKeys,
			trace: trace,
			txp:   httpTransport,
		},
		CheckRedirect: nil,
		Jar:           nil,
		Timeout:       tcpTimeout,
	}
	defer httpClnt.CloseIdleConnections()

	// create HTTP request
	httpReq, err := t.newHTTPRequest(httpCtx)
	if err != nil {
		t.TestKeys.SetFundamentalFailure(err)
		ol.Stop(err)
		return
	}

	// perform HTTP transaction
	httpResp, err := httpClnt.Do(httpReq)
	if err != nil {
		ol.Stop(err)
		return
	}

	// TODO: insert here additional code if needed
	_ = httpResp

	// completed successfully
	ol.Stop(nil)
}

// newHTTPRequest creates a new HTTP request.
func (t *Redirects) newHTTPRequest(ctx context.Context) (*http.Request, error) {
	httpReq, err := http.NewRequestWithContext(ctx, "GET", t.Location.String(), nil)
	if err != nil {
		return nil, err
	}
	httpReq.Header.Set("Host", t.Location.Host)
	httpReq.Header.Set("Accept", model.HTTPHeaderAccept)
	httpReq.Header.Set("Accept-Language", model.HTTPHeaderAcceptLanguage)
	httpReq.Header.Set("User-Agent", model.HTTPHeaderUserAgent)
	httpReq.Host = t.Location.Host
	return httpReq, nil
}

// redirectsTransport wraps transport to save minimal information
// about subsequent HTTP redirects
type redirectsTransport struct {
	// tk contains the test keys
	tk *TestKeys

	// trace is the trace we're using
	trace *measurexlite.Trace

	// txp is the transport we're using
	txp model.HTTPTransport
}

// CloseIdleConnections forwards the CloseIdleConnection call
func (t *redirectsTransport) CloseIdleConnections() {
	t.txp.CloseIdleConnections()
}

// RoundTrip implements http.Transport.
func (t *redirectsTransport) RoundTrip(req *http.Request) (*http.Response, error) {
	const maxbody = 1 << 22 // TODO: you may want to change this default
	resp, err := t.txp.RoundTrip(req)
	if err != nil {
		ev := t.trace.NewArchivalHTTPRequestResult(t.txp, req, resp, maxbody, []byte{}, err)
		t.tk.AppendRequests(ev)
		return nil, err
	}
	defer resp.Body.Close()
	reader := io.LimitReader(resp.Body, maxbody)
	body, err := netxlite.ReadAllContext(req.Context(), reader)
	ev := t.trace.NewArchivalHTTPRequestResult(t.txp, req, resp, maxbody, body, err)
	t.tk.AppendRequests(ev)
	if err != nil {
		return nil, err
	}
	resp.Body = &redirectsBody{
		r: bytes.NewReader(body),
	}
	return resp, nil
}

// redirectsBody is the body used by redirectsTransport
type redirectsBody struct {
	// r is the reader
	r io.Reader
}

// Read implements io.Reader
func (rb *redirectsBody) Read(b []byte) (int, error) {
	return rb.r.Read(b)
}

// Close implements io.Closer
func (rb *redirectsBody) Close() error {
	return nil
}
